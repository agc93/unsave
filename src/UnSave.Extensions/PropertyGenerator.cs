using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using Microsoft.CodeAnalysis;
using UnSave.Types;

namespace UnSave.Extensions
{
    [Generator]
    public class PropertyGenerator : ISourceGenerator
    {
        public void Initialize(GeneratorInitializationContext context) {
            context.RegisterForSyntaxNotifications(() => new AttributeReceiver());
#if DEBUG
            if (!Debugger.IsAttached)
            {
                Debugger.Launch();
            }
#endif 
        }

        public void Execute(GeneratorExecutionContext context) {
            var receiver = (AttributeReceiver)context.SyntaxReceiver;

            foreach (var classDeclarationSyntax in receiver.Candidates.Select(c => c.Value))
            {
                var model = context.Compilation.GetSemanticModel(classDeclarationSyntax.SyntaxTree, true);
                var declaredSymbol = model.GetDeclaredSymbol(classDeclarationSyntax);
                /*var attr = classDeclarationSyntax.AttributeLists.First().Attributes
                    .First(a => a.Name.ExtractName() == "SaveProperty");
                var attrSym = model.GetDeclaredSymbol(attr);*/
                
                
                var field = declaredSymbol as ITypeSymbol;
                

                if (field is null)
                    continue;
                
                // var code = GenerateCode(field, model);
                var code = GenerateClassPropertyCode(field, model);
                if (code is not null) {
                    context.AddSource($"{field.Name}_Generated.cs", code);
                }
            }

            foreach (var propertyDeclarationSyntax in receiver.ViewCandidates) {
                var model = context.Compilation.GetSemanticModel(propertyDeclarationSyntax.SyntaxTree, true);
                var declaredSymbol = model.GetDeclaredSymbol(propertyDeclarationSyntax);
                var property = declaredSymbol as IPropertySymbol;
                if (property is null) continue;
                var code = GeneratePropertyCode(property, model);
                var classSym = property.ContainingType.Name;
                context.AddSource($"{classSym}_{property.Name}_Generated.cs", code);
            }
        }

        private static string GeneratePropertyCode(IPropertySymbol property, SemanticModel model) {
            var ns = property.ContainingNamespace.ToString();
            var name = property.Name;
            var targetType = property.Type;
            var baseType = property.Type.BaseType; //this is UnrealPropertyBase<something>
            var targetPropertyType = baseType.TypeArguments.First();
            var classSym = property.ContainingType.Name;
            
            var attr = property.GetAttributes().First();
            // var viewPropName = attr.ConstructorArguments.First(a => a.Type.Name == "String").Value as string;
            var viewPropertySpecifier =
                attr.NamedArguments.FirstOrDefault(na => na.Key == nameof(ViewPropertyAttribute.ViewPropertyName));
            var viewPropertyName = string.IsNullOrWhiteSpace(viewPropertySpecifier.Key)
                ? $"{name}Value"
                : viewPropertySpecifier.Value.Value as string;
            var readOnlyPropertySpecifier = 
                attr.NamedArguments.FirstOrDefault(na => na.Key == nameof(ViewPropertyAttribute.ReadOnly));
            var readOnlyProperty = string.IsNullOrWhiteSpace(viewPropertySpecifier.Key) && (bool.TryParse(viewPropertySpecifier.Value.Value as string, out var roProp) && roProp);
            var propertyBody = readOnlyProperty
                ? @$"get {{ return {name}?.Value; }}"
                : @$"get {{ return {name}?.Value; }}
set {{ if ({name}?.Value is not null) {name}.Value = ({targetPropertyType.Name})value; }}";
            
            
            var gen = @$"// <auto-generated />
using {targetPropertyType.ContainingNamespace};
using {targetType.ContainingNamespace};
using System.Collections.Generic;

{(String.IsNullOrWhiteSpace(ns) ? null : $"namespace {ns}")}
{{
   public partial class {classSym}
   {{
      public {targetPropertyType.Name}? {viewPropertyName} {{
        {propertyBody}
      }}
   }}
}}
";
            return gen;

        }

        private static string? GenerateClassPropertyCode(ITypeSymbol classSymbol, SemanticModel model) {
            var ns = classSymbol.ContainingNamespace.ToString();
            var className = classSymbol.Name;

            var saveDataProp = classSymbol.GetMembers().Where(m => m is IPropertySymbol).Cast<IPropertySymbol>()
                .FirstOrDefault(p => p.Type.Name.Contains(nameof(GvasSaveData)));
            if (saveDataProp != null) {
                var propCodes = new List<string>();
                var nss = new List<string>();
                var attrs = classSymbol.GetAttributes();
                foreach (var attr in attrs) {
                    var savePropName = attr.ConstructorArguments.First(a => a.Type.Name == "String").Value as string;
                    var savePropType = attr.ConstructorArguments.First(a => a.Kind == TypedConstantKind.Type).Value as ITypeSymbol;
                    var baseType = savePropType.BaseType; //this is UnrealPropertyBase<something>
                    nss.Add(baseType.ContainingNamespace.ToString());
                    var targetPropertyType = baseType.TypeArguments.First();
                    nss.Add(targetPropertyType.ContainingNamespace.ToString());
                    var viewPropertySpecifier =
                        attr.NamedArguments.FirstOrDefault(na => na.Key == nameof(SavePropertyAttribute.PropertyName));
                    var viewPropertyName = string.IsNullOrWhiteSpace(viewPropertySpecifier.Key)
                        ? $"{savePropName}"
                        : viewPropertySpecifier.Value.Value as string;
                    var includeValuePropertySpecifier = 
                        attr.NamedArguments.FirstOrDefault(na => na.Key == nameof(SavePropertyAttribute.IncludeValueProperty));
                    var includeValueProperty = string.IsNullOrWhiteSpace(includeValuePropertySpecifier.Key) && (bool.TryParse(includeValuePropertySpecifier.Value.Value as string, out var roProp) && roProp);
                    var propCode =
                        $@"public {savePropType.Name}? {viewPropertyName} => {saveDataProp.Name}.Properties.FindProperty<{savePropType.Name}>(p => p.Name == {('"' + savePropName + '"')});";
                    if (includeValueProperty) {
                        propCode = Environment.NewLine +
                                   $"public {targetPropertyType.Name}? {viewPropertyName}Value => {viewPropertyName}?.Value;";
                    }
                    propCodes.Add(propCode);
                }

                var usings = string.Join(Environment.NewLine, nss.Distinct().Select(ns => $"using {ns};"));

                var gen = $@"// <auto-generated />
{usings}
using System.Collections.Generic;

{(String.IsNullOrWhiteSpace(ns) ? null : $"namespace {ns}")}
{{
   public partial class {className}
   {{
      {string.Join(Environment.NewLine, propCodes)}
   }}
}}
";
                return gen;
            }

            return null;
        }

        /*private static string GenerateCode(IFieldSymbol field, SemanticModel model)
        {
            var ns = field.ContainingNamespace.ToString();
            var name = field.Name;
            var targetType = field.Type;
            var baseType = field.Type.BaseType; //this is UnrealPropertyBase<something>
            var targetPropertyType = baseType.TypeArguments.First();
            var classSym = field.ContainingType.Name;
            var targetPropertyName = name.TrimStart('_').FirstCharToUpper();
            var attr = field.GetAttributes().First();
            var savePropName = attr.ConstructorArguments.First(a => a.Type.Name == "String").Value as string;
            var saveDataPropertySpecifier =
                attr.NamedArguments.FirstOrDefault(na => na.Key == nameof(SavePropertyAttribute.SaveData));
            var saveDataPropertyName = string.IsNullOrWhiteSpace(saveDataPropertySpecifier.Key)
                ? "saveData"
                : saveDataPropertySpecifier.Value.Value as string;
            // var items = GetItemNames(type);

            var gen = @$"// <auto-generated />
using {targetPropertyType.ContainingNamespace};
using {targetType.ContainingNamespace};
using System.Collections.Generic;

{(String.IsNullOrWhiteSpace(ns) ? null : $"namespace {ns}")}
{{
   public partial class {classSym}
   {{
      public {targetType}? {targetPropertyName} => {saveDataPropertyName}.Properties.FindProperty<{targetType.Name}>(p => p.Name == {('"' + savePropName + '"')});
      public {targetPropertyType.Name}? {targetPropertyName}Value => {targetPropertyName}?.Value;
   }}
}}
";
            return gen;
        }*/
    }
}