using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using Microsoft.CodeAnalysis;
using UnSave.Types;

namespace UnSave.Extensions
{
    [Generator]
    public class PropertyGenerator : ISourceGenerator
    {
        public void Initialize(GeneratorInitializationContext context) {
            context.RegisterForSyntaxNotifications(() => new AttributeReceiver());
#if DEBUG
            if (!Debugger.IsAttached)
            {
                Debugger.Launch();
            }
#endif 
        }

        public void Execute(GeneratorExecutionContext context) {
            var receiver = (AttributeReceiver)context.SyntaxReceiver;

            foreach (var classDeclarationSyntax in receiver.Candidates.Select(c => c.Value))
            {
                var model = context.Compilation.GetSemanticModel(classDeclarationSyntax.SyntaxTree, true);
                var declaredSymbol = model.GetDeclaredSymbol(classDeclarationSyntax);

                var field = declaredSymbol as ITypeSymbol;

                if (field is null)
                    continue;
                
                var code = GenerateClassPropertyCode(field, model);
                if (code is not null) {
                    context.AddSource($"{field.Name}_Generated.cs", code);
                }
            }

            foreach (var propertyDeclarationSyntax in receiver.ViewCandidates) {
                var model = context.Compilation.GetSemanticModel(propertyDeclarationSyntax.SyntaxTree, true);
                var declaredSymbol = model.GetDeclaredSymbol(propertyDeclarationSyntax);
                var property = declaredSymbol as IPropertySymbol;
                if (property is null) continue;
                var code = GenerateValuePropertyCode(property, model);
                var classSym = property.ContainingType.Name;
                context.AddSource($"{classSym}_{property.Name}_Generated.cs", code);
            }
        }

        private static string GenerateValuePropertyCode(IPropertySymbol property, SemanticModel model) {
            var ns = property.ContainingNamespace.ToString();
            var name = property.Name;
            var targetType = property.Type;
            var baseType = property.Type.BaseType; //this is UnrealPropertyBase<something>
            var targetPropertyType = baseType.TypeArguments.First();
            var classSym = property.ContainingType.Name;
            
            var attr = property.GetAttributes().First();
            // var viewPropName = attr.ConstructorArguments.First(a => a.Type.Name == "String").Value as string;
            var viewPropertySpecifier =
                attr.NamedArguments.FirstOrDefault(na => na.Key == nameof(ValuePropertyAttribute.ValuePropertyName));
            var viewPropertyName = string.IsNullOrWhiteSpace(viewPropertySpecifier.Key)
                ? $"{name}Value"
                : viewPropertySpecifier.Value.Value as string;
            var readOnlyProperty = attr.GetFlag(nameof(ValuePropertyAttribute.ReadOnly));
            var propertyBody = readOnlyProperty
                ? @$"get {{ return {name}?.Value; }}"
                : @$"get {{ return {name}?.Value; }}
set {{ if ({name}?.Value is not null) {name}.Value = ({targetPropertyType.Name})value; }}";
            
            
            var gen = @$"// <auto-generated />
#nullable enable annotations
using {targetPropertyType.ContainingNamespace};
using {targetType.ContainingNamespace};
using System.Collections.Generic;

{(String.IsNullOrWhiteSpace(ns) ? null : $"namespace {ns}")}
{{
   public partial class {classSym}
   {{
      public {targetPropertyType.Name}? {viewPropertyName} {{
        {propertyBody}
      }}
   }}
}}
#nullable restore annotations
";
            return gen;

        }

        private static string? GenerateClassPropertyCode(ITypeSymbol classSymbol, SemanticModel model) {
            var ns = classSymbol.ContainingNamespace.ToString();
            var className = classSymbol.Name;

            var saveDataProp = classSymbol.GetMembers().Where(m => m is IPropertySymbol).Cast<IPropertySymbol>()
                .FirstOrDefault(p => p.Type.Name.Contains(nameof(GvasSaveData)));
            if (saveDataProp != null) {
                var propCodes = new List<string>();
                var nss = new List<string>();
                var attrs = classSymbol.GetAttributes();
                foreach (var attr in attrs) {
                    var savePropName = attr.ConstructorArguments.First(a => a.Type.Name == "String").Value as string;
                    var savePropType = attr.ConstructorArguments.First(a => a.Kind == TypedConstantKind.Type).Value as ITypeSymbol;
                    var baseType = savePropType.BaseType; //this is UnrealPropertyBase<something>
                    nss.Add(baseType.ContainingNamespace.ToString());
                    var targetPropertyType = baseType.TypeArguments.First();
                    nss.Add(targetPropertyType.ContainingNamespace.ToString());
                    var viewPropertySpecifier =
                        attr.NamedArguments.FirstOrDefault(na => na.Key == nameof(SavePropertyAttribute.PropertyName));
                    var viewPropertyName = string.IsNullOrWhiteSpace(viewPropertySpecifier.Key)
                        ? $"{savePropName}"
                        : viewPropertySpecifier.Value.Value as string;
                    var includeValueProperty = attr.GetFlag(nameof(SavePropertyAttribute.IncludeValueProperty));
                    
                    var propCode =
                        $@"public {savePropType.Name}? {viewPropertyName} => {saveDataProp.Name}.Properties.FindProperty<{savePropType.Name}>(p => p.Name == {('"' + savePropName + '"')});";
                    if (includeValueProperty) {
                        propCode = propCode.AddAfter(
                            $"public {targetPropertyType.Name}? {viewPropertyName}Value => {viewPropertyName}?.Value;");
                    }
                    propCodes.Add(propCode);
                }

                var usings = string.Join(Environment.NewLine, nss.Distinct().Select(ns => $"using {ns};"));

                var gen = $@"// <auto-generated />
#nullable enable annotations
{usings}
using System.Collections.Generic;

{(String.IsNullOrWhiteSpace(ns) ? null : $"namespace {ns}")}
{{
   public partial class {className}
   {{
      {string.Join(Environment.NewLine, propCodes)}
   }}
}}
#nullable restore annotations
";
                return gen;
            }

            return null;
        }
    }
}